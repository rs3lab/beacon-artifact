diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c
index 97ec005c3c47..8cf4d0a84e5e 100644
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@ -64,6 +64,41 @@
 # endif
 #endif
 
+struct hooked_prog one_hook_prog;
+
+int reset_hook_record(void) {
+	int i;
+	one_hook_prog.maps_cnt = 0;
+	one_hook_prog.progs_cnt = 0;
+	for (i = 0; i < 20; i++) {
+		free(one_hook_prog.maps_info[i].map_attr);
+		one_hook_prog.maps_info[i].map_attr = NULL;
+		free(one_hook_prog.progs_attr[i]);
+		one_hook_prog.progs_attr[i] = NULL;
+	}
+	return 0;
+}
+
+struct hooked_prog* get_hook_record(void){
+	return &one_hook_prog;
+}
+
+void mark_map_fd(union bpf_attr *prog_attr, struct hooked_prog *prog) {
+	int i = 0, j = 0;
+	for (i = 0; i < prog_attr->insn_cnt; i++) {
+		struct bpf_insn *cur_insn = ((struct bpf_insn *)(prog_attr->insns)) + i;
+		// BPF_LD_MAP_FD
+		if (cur_insn->code == (BPF_LD | BPF_DW | BPF_IMM) && cur_insn->src_reg == BPF_PSEUDO_MAP_FD) {
+			for (j = 0; j < prog->maps_cnt; j++) {
+				if (prog->maps_info[j].runtime_fd == cur_insn->imm) {
+					cur_insn->imm = i;
+					break;
+				}
+			}
+		}
+	}
+}
+
 static inline __u64 ptr_to_u64(const void *ptr)
 {
 	return (__u64) (unsigned long) ptr;
@@ -72,7 +107,25 @@ static inline __u64 ptr_to_u64(const void *ptr)
 static inline int sys_bpf(enum bpf_cmd cmd, union bpf_attr *attr,
 			  unsigned int size)
 {
-	return syscall(__NR_bpf, cmd, attr, size);
+	int ret = syscall(__NR_bpf, cmd, attr, size);
+
+	union bpf_attr *one_attr = (union bpf_attr*)malloc(sizeof(union bpf_attr));
+        if(one_attr == NULL) {
+                printf("malled failed\n");
+                exit(0);
+        }
+        memcpy(one_attr, attr, sizeof(union bpf_attr));
+        if (cmd == BPF_MAP_CREATE) {
+                one_hook_prog.maps_info[one_hook_prog.maps_cnt].map_attr = one_attr;
+                one_hook_prog.maps_info[one_hook_prog.maps_cnt].runtime_fd = ret;
+                one_hook_prog.maps_cnt ++;
+        } else if (cmd == BPF_PROG_LOAD) {
+		printf("progs_cnt: %d\n", one_hook_prog.progs_cnt);
+		one_hook_prog.progs_attr[one_hook_prog.progs_cnt] = one_attr;
+                one_hook_prog.progs_cnt ++;
+        }
+
+	return ret;
 }
 
 static inline int sys_bpf_fd(enum bpf_cmd cmd, union bpf_attr *attr,
@@ -88,6 +141,7 @@ int sys_bpf_prog_load(union bpf_attr *attr, unsigned int size, int attempts)
 {
 	int fd;
 
+	printf("hooked\n");
 	do {
 		fd = sys_bpf_fd(BPF_PROG_LOAD, attr, size);
 	} while (fd < 0 && errno == EAGAIN && --attempts > 0);
@@ -248,7 +302,6 @@ int bpf_prog_load(enum bpf_prog_type prog_type,
 	char *log_buf;
 
 	bump_rlimit_memlock();
-
 	if (!OPTS_VALID(opts, bpf_prog_load_opts))
 		return libbpf_err(-EINVAL);
 
diff --git a/tools/lib/bpf/bpf.h b/tools/lib/bpf/bpf.h
index df0db2f0cdb7..94e0e25b96db 100644
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@ -111,6 +111,23 @@ struct bpf_prog_load_opts {
 };
 #define bpf_prog_load_opts__last_field token_fd
 
+struct map_info {
+	union bpf_attr *map_attr;
+	int runtime_fd;
+};
+
+struct hooked_prog {
+        int maps_cnt;
+        struct map_info maps_info[200];
+        int progs_cnt;
+        union bpf_attr *progs_attr[200];
+
+};
+
+LIBBPF_API int reset_hook_record(void);
+LIBBPF_API struct hooked_prog* get_hook_record(void);
+LIBBPF_API void mark_map_fd(union bpf_attr *prog_attr, struct hooked_prog *prog);
+
 LIBBPF_API int bpf_prog_load(enum bpf_prog_type prog_type,
 			     const char *prog_name, const char *license,
 			     const struct bpf_insn *insns, size_t insn_cnt,
diff --git a/tools/lib/bpf/libbpf.c b/tools/lib/bpf/libbpf.c
index efab29b8935b..cf3419e4afa3 100644
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@ -7756,6 +7756,11 @@ bpf_object__load_progs(struct bpf_object *obj, int log_level)
 		if (obj->gen_loader)
 			bpf_program_record_relos(prog);
 
+		/*
+		if (prog && prog->name) {
+			memcpy(prog->name, "self", 4);
+		}
+		*/
 		err = bpf_object_load_prog(obj, prog, prog->insns, prog->insns_cnt,
 					   obj->license, obj->kern_version, &prog->fd);
 		if (err) {
diff --git a/tools/lib/bpf/libbpf.map b/tools/lib/bpf/libbpf.map
index 86804fd90dd1..e8c471df166e 100644
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@ -293,6 +293,9 @@ LIBBPF_0.6.0 {
 		bpf_object__next_program;
 		bpf_object__prev_map;
 		bpf_object__prev_program;
+		reset_hook_record;
+		get_hook_record;
+		mark_map_fd;
 		bpf_prog_load;
 		bpf_program__flags;
 		bpf_program__insn_cnt;
diff --git a/tools/testing/selftests/bpf/Makefile b/tools/testing/selftests/bpf/Makefile
index 3b9eb40d6343..b7c4d172e418 100644
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@ -28,18 +28,19 @@ BPF_GCC		?= $(shell command -v bpf-gcc;)
 SAN_CFLAGS	?=
 SAN_LDFLAGS	?= $(SAN_CFLAGS)
 RELEASE		?=
-OPT_FLAGS	?= $(if $(RELEASE),-O2,-O0)
+#OPT_FLAGS	?= $(if $(RELEASE),-O2,-O0)
+OPT_FLAGS      ?= $(-O0 -g)
 
 LIBELF_CFLAGS	:= $(shell $(PKG_CONFIG) libelf --cflags 2>/dev/null)
 LIBELF_LIBS	:= $(shell $(PKG_CONFIG) libelf --libs 2>/dev/null || echo -lelf)
 
-CFLAGS += -g $(OPT_FLAGS) -rdynamic					\
+CFLAGS += -g -O0 $(OPT_FLAGS) -rdynamic					\
 	  -Wall -Werror -fno-omit-frame-pointer				\
 	  $(GENFLAGS) $(SAN_CFLAGS) $(LIBELF_CFLAGS)			\
 	  -I$(CURDIR) -I$(INCLUDE_DIR) -I$(GENDIR) -I$(LIBDIR)		\
 	  -I$(TOOLSINCDIR) -I$(APIDIR) -I$(OUTPUT)
 LDFLAGS += $(SAN_LDFLAGS)
-LDLIBS += $(LIBELF_LIBS) -lz -lrt -lpthread
+LDLIBS += $(LIBELF_LIBS) -lz -lrt -lpthread -L$(PWD) -lverify
 
 # The following tests perform type punning and they may break strict
 # aliasing rules, which are exploited by both GCC and clang by default
diff --git a/tools/testing/selftests/bpf/test_loader.c b/tools/testing/selftests/bpf/test_loader.c
index 42701ec0212f..4eb41d0a0518 100644
--- a/tools/testing/selftests/bpf/test_loader.c
+++ b/tools/testing/selftests/bpf/test_loader.c
@@ -4,6 +4,7 @@
 #include <stdlib.h>
 #include <test_progs.h>
 #include <bpf/btf.h>
+#include <string.h>
 
 #include "autoconf_helper.h"
 #include "unpriv_helpers.h"
@@ -650,6 +651,8 @@ static bool should_do_test_run(struct test_spec *spec, struct test_subspec *subs
 	return true;
 }
 
+int VerifyOneProg(char *progAttr, void **mapsAttr, int priv, char *itm_states, int runtime_res, char *workdir, char *dafny_veri_log);
+
 /* this function is forced noinline and has short generic name to look better
  * in test_progs output (in case of a failure)
  */
@@ -671,6 +674,7 @@ void run_subtest(struct test_loader *tester,
 	int retval, err, i;
 	bool should_load, unpriv = (priv_level != PRIV);
 
+	printf("run_subtest\n");
 	switch (priv_level) {
 		case PRIV:
 			subspec = &spec->priv;
@@ -740,6 +744,10 @@ void run_subtest(struct test_loader *tester,
 	bpf_object__for_each_map(map, tobj)
 		bpf_map__set_autocreate(map, !unpriv || is_unpriv_capable_map(map));
 
+	//
+	reset_hook_record();
+	//
+
 	err = bpf_object__load(tobj);
 	if (subspec->expect_failure) {
 		if (!ASSERT_ERR(err, "unexpected_load_success")) {
@@ -756,7 +764,36 @@ void run_subtest(struct test_loader *tester,
 	emit_verifier_log(tester->log_buf, false /*force*/);
 	validate_case(tester, subspec, tobj, tprog, err);
 
-	if (should_do_test_run(spec, subspec)) {
+	struct hooked_prog *hook_info = get_hook_record();
+
+	union bpf_attr *maps_attr[30];
+	for (i = 0; i < hook_info->maps_cnt; i++) {
+		maps_attr[i] = hook_info->maps_info[i].map_attr;
+	}
+
+	char dafny_veri_log[4194304];
+        printf("output: hook_info: %d %d\n", hook_info->maps_cnt, hook_info->progs_cnt);
+        for (i = 0; i < hook_info->progs_cnt; i++) {
+                if (strcmp(hook_info->progs_attr[i]->prog_name, "det_arg_ctx") &&
+		    strcmp(hook_info->progs_attr[i]->prog_name, "")) {
+			printf("output: prog name: %s, len: %ld\n", hook_info->progs_attr[i]->prog_name, strlen(hook_info->progs_attr[i]->prog_name));
+                        printf("output: insn count: %d\n", hook_info->progs_attr[i]->insn_cnt);
+
+			// Convert the real map fd as the map index in the test
+			mark_map_fd(hook_info->progs_attr[i], hook_info);
+
+			VerifyOneProg((char *)hook_info->progs_attr[i],
+				(void **)maps_attr,
+				1,
+                                NULL,
+                                (subspec->expect_failure ? -1:1),
+                                "./workdir/",
+                                dafny_veri_log
+                             );
+                }
+        }
+
+	if (should_do_test_run(spec, subspec) && false) {
 		/* For some reason test_verifier executes programs
 		 * with all capabilities restored. Do the same here.
 		 */
@@ -852,5 +889,6 @@ void test_loader__run_subtests(struct test_loader *tester,
 			       skel_elf_bytes_fn elf_bytes_factory)
 {
 	/* see comment in run_subtest() for why we do this function nesting */
+	printf("test_loader__run_subtests\n");
 	process_subtest(tester, skel_name, elf_bytes_factory);
 }
diff --git a/tools/testing/selftests/bpf/test_verifier.c b/tools/testing/selftests/bpf/test_verifier.c
index df04bda1c927..d12fcc4dd79d 100644
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@ -1510,6 +1510,8 @@ static bool check_xlated_program(struct bpf_test *test, int fd_prog)
 	return result;
 }
 
+int VerifyOneProg(char *progAttr, void **mapsAttr, int priv, char *itm_states, int runtime_res, char *workdir, char *dafny_veri_log);
+
 static void do_test_single(struct bpf_test *test, bool unpriv,
 			   int *passes, int *errors)
 {
@@ -1525,6 +1527,9 @@ static void do_test_single(struct bpf_test *test, bool unpriv,
 	int fixup_skips;
 	__u32 pflags;
 	int i, err;
+	char dafny_veri_log[4194304];
+
+	reset_hook_record();
 
 	if ((test->flags & F_NEEDS_JIT_ENABLED) && jit_disabled) {
 		printf("SKIP (requires BPF JIT)\n");
@@ -1609,7 +1614,7 @@ static void do_test_single(struct bpf_test *test, bool unpriv,
 
 	opts.log_buf = bpf_vlog;
 	opts.log_size = sizeof(bpf_vlog);
-	fd_prog = bpf_prog_load(prog_type, NULL, "GPL", prog, prog_len, &opts);
+	fd_prog = bpf_prog_load(prog_type, "selftest", "GPL", prog, prog_len, &opts);
 	saved_errno = errno;
 
 	/* BPF_PROG_TYPE_TRACING requires more setup and
@@ -1672,6 +1677,37 @@ static void do_test_single(struct bpf_test *test, bool unpriv,
 	if (verbose)
 		printf(", verifier log:\n%s", bpf_vlog);
 
+	struct hooked_prog *hook_info = get_hook_record();
+
+	union bpf_attr *maps_attr[30];
+        for (i = 0; i < hook_info->maps_cnt; i++) {
+                maps_attr[i] = hook_info->maps_info[i].map_attr;
+        }
+
+	printf("\nmap: %d, progs: %d\n", hook_info->maps_cnt, hook_info->progs_cnt);
+	for (i = 0; i < hook_info->progs_cnt; i++) {
+		// printf("prog name: %s\n", hook_info->progs_attr[i]->prog_name);
+		if (!strcmp(hook_info->progs_attr[i]->prog_name, "selftest")) {
+			// printf("insn count: %d\n", hook_info->progs_attr[i]->insn_cnt);
+
+			// Convert the real map fd as the map index in the test
+                        mark_map_fd(hook_info->progs_attr[i], hook_info);
+
+			VerifyOneProg((char *)hook_info->progs_attr[i],
+				(void **)maps_attr,
+				1,
+				NULL,
+				(expected_ret == ACCEPT || expected_ret == VERBOSE_ACCEPT) ? 1:-1,
+				"./workdir/",
+				dafny_veri_log
+			     );
+		}
+	}
+	// char *progAttr, char *itm_states, int runtime_res, char *workdir, dafny_veri_log) 
+	goto close_fds;
+	/////////////////////////////
+
+
 	if (!check_xlated_program(test, fd_prog))
 		goto fail_log;
 
@@ -1787,7 +1823,7 @@ static int do_test(bool unpriv, unsigned int from, unsigned int to)
 		} else if (test_as_unpriv(test)) {
 			if (!unpriv)
 				set_admin(false);
-			printf("#%d/u %s ", i, test->descr);
+			printf("#%d/u %s \n", i, test->descr);
 			do_test_single(test, true, &passes, &errors);
 			if (!unpriv)
 				set_admin(true);
